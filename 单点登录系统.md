#### 基于cookie和session的登录验证

由于http协议是不储存状态的（stateless），这意味着服务器在响应客户端请求时不会识别请求是哪个客户端发的。然而，许多Web应用程序的安全和正常运行都取决于系统能够区分用户并识别用户及其权限。

简言之就是每次request不会和用户相关联，是独立的，那如何建立连接呢？

+ 用户将账号与密码等凭据发送给服务器
+ 服务器验证凭据是否正确，生成一条包含用户身份的记录，也就是session，存储在数据库中
+ 再将这条记录发送给用户并存储在用户本地浏览器，即cookie
+ 接下来用户的请求都会带上这条cookie，若客户端的cookie与服务端的session能对应上，则说明用户身份验证通过
+ 一旦用户登出，服务端和客户端同时销毁该会话

![cookie](https://upload-images.jianshu.io/upload_images/2846604-a8fa7e1bef110bd6.png?imageMogr2/auto-orient/strip|imageView2/2/w/830/format/webp 'cookie')

> 有哪些问题？

+ 性能：意味着每登录一个用户，服务器就需要准备一块内存来储存用户session信息，登录者越多，占用内存越多。同时，一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多。

+ 扩展性：由于session储存在内存就会造成扩展时的问题，当我们使用云服务增加服务器执行负载均衡的时候，把这些重要的资料储存在内存会受到一些限制，类似转载，分享等无法实现

+ 跨站：即多站点使用，cookie绑定到单个域。例如foo.com域产生的cookie无法被bar.com域读取。使用token就没有这样的问题。这对于需要向多个服务获取授权的单页面应用程序尤其有用

+ 跨站请求伪造（CSRF）：举个CSRF攻击的例子，在网页中有这样的一个链接
   `![](http://bank.com?withdraw=1000&to=tom)`，假设你已经通过银行的验证并且cookie中存在验证信息，同时银行网站没有CSRF保护。一旦用户点了这个图片，就很有可能从银行向tom这个人转1000块钱。

  但是如果银行网站使用了token作为验证手段，攻击者将无法通过上面的链接转走你的钱。（因为攻击者无法获取正确的token）

#### 基于token的登录验证（JWT）

基于token的验证是无状态的，这也许是它相对cookie来说最大的优点。后端服务不需要记录token。每个令牌都是独立的，包括检查其有效性所需的所有数据，并通过声明传达用户信息。

服务器唯一的工作就是在成功的登陆请求上签署token，并验证传入的token是否有效。

![cookie](https://upload-images.jianshu.io/upload_images/2846604-cf06c14fb4af243b.png?imageMogr2/auto-orient/strip|imageView2/2/w/872/format/webp 'cookie')

> `JWT` —  `JSON Web Token`

JWT包括三个部分：头部、载荷和签名，这三个部分通过`.`连接起来

一个典型的JWT长这样`xxxxx.yyyyy.zzzzz`

###### 头部

头部通常包括两部分：token类型（JWT），和使用到的算法

头部会通过**Base64Url**编码形成JWT的第一部分

###### 载荷

第二部分是载荷，要传递出去的声明，其中包含了实体（通常是用户）和附加元数据。

载荷会通过**Base64Url**编码形成JWT的第二部分

###### 签名

将上面两部分编码后，使用`.`连接在一起，形成了xxxxx.yyyyyy

最后，采用头部指定的算法，和私钥对上面的字符串进行签名

例如采用的是HMAC SHA256 算法，签名将通过下面的方式生成

```
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```

> Tips：载荷传递的信息（是我们存放我们需要的信息的部分）是用BASE64编码的，所以很容易被解码，一定不能存放明文密码这种关键信息！替代地可以存放一些不是特别关键的信息，比如用户id这样能够做区分的信息

